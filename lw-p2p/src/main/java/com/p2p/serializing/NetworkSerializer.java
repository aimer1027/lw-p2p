package com.p2p.serializing;

import io.netty.buffer.ByteBuf;

import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

import com.backends.MessageInfo;

/**
 * Basic Serializer for use in a SerializingTable. 
 * 
 * @author William Laroche
 *
 * @param <Item> The type of object this serializer can serialize.
 */
abstract public class NetworkSerializer<Item> {
	
	public static class ByteCountCheckException extends RuntimeException{
		/**
		 * 
		 */
		private static final long serialVersionUID = -4905438496096300971L;

		public ByteCountCheckException(){
			super("Byte count check failed. The implemented NetworkSerializer has read a "
					+ "different number of bytes that what was written before packet expedition.");
		}
	}
	
	private List<P2PMessageListener<Item>> listeners;
	short opcode;
	
	public NetworkSerializer(){
		listeners = new ArrayList<P2PMessageListener<Item>>();
		opcode = generateOpcode();
	}
	
	public final void addListener(P2PMessageListener<Item> listener){
		listeners.add(listener);
	}
	
	public final Item decode(ByteBuf stream, MessageInfo messageInfo){
		return decode(stream, messageInfo, null);
	}
	
	public final Item decode(ByteBuf stream, MessageInfo messageInfo, SerializingTable table, boolean notifyListeners){
		int expectedBytes = readByteCount(stream);
		int startingIndex = stream.readerIndex();
		
		Item item = read(stream, expectedBytes, table);
		
		int readBytes = stream.readerIndex() - startingIndex;
		if(readBytes != expectedBytes)
			throw new ByteCountCheckException();
		if(notifyListeners)
			notifyListeners(item, messageInfo);
		return item;
	}
	
	public final Item decode(ByteBuf stream, MessageInfo messageInfo, SerializingTable table) throws ByteCountCheckException{
		return decode(stream, messageInfo, table, true);
		
	}
	
	private int readByteCount(ByteBuf stream){
		return stream.readShort();
	}
	
	private void notifyListeners(Item i, MessageInfo info){
		for(P2PMessageListener<Item> listener : listeners){
			listener.messageReceived(i, info);
		}
	}
	
	/**Casts the object to this Serializer's type, and calls encode(ByteBuf, Item, SerializingTable);
	 * 
	 * @param stream
	 * @param object
	 * @param table
	 */
	public final void encodeCast(ByteBuf stream, Object object, SerializingTable table){
		encode(stream, (Item) object, table);
	}
	
	/**Casts the object to this Serializer's type, and calls encode(ByteBuf, Item);
	 * 
	 * @param stream
	 * @param object
	 */
	public final void encodeCast(ByteBuf stream, Object object){
		encode(stream, (Item) object);
	}
	
	/**Encodes the object into the buffer. Some serializers may not support this operation,
	 *  since no serializing table is supplied.
	 * 
	 * @param stream The buffer
	 * @param object The object.
	 */
	public final void encode(ByteBuf stream, Item object){
		encode(stream, object, null);
	}
	
	/**Encodes into the buffer the specified object.
	 * 
	 * @param stream The buffer on which to write to.
	 * @param object The object to write.
	 * @param table The serializing table to which this Serializer is attached.
	 */
	public final void encode(ByteBuf stream, Item object, SerializingTable table){
		
		//Reserve a short for writing byte count
		int byteCountIndex = stream.writerIndex();
		stream.writeShort(0);
		
		//Write the object
		int startingIndex = stream.writerIndex();
		write(stream, object, table);
		
		//Write the byteCount at the byteCountIndex
		int byteCount = stream.writerIndex() - startingIndex;
		writeByteCount(stream, byteCount , byteCountIndex);
	}
	
	private void writeByteCount(ByteBuf stream, int byteCount, int writeIndex){
		stream.markWriterIndex();
		stream.writerIndex(writeIndex);
		stream.writeShort(byteCount);
		stream.resetWriterIndex();
	}
	
	private short generateOpcode(){
		String name = this.getClass().getName();
		short opcode = 55;
		
		if(name != null)
			opcode = (short) name.hashCode();
		
		return opcode;
	}
	
	/**Defines a unique opcode. An opcode is generated by default with the name of the class.
	 *  Can be overridden for custom opcodes, but not recommended.
	 * 
	 * @return the unique and unvariable opcode.
	 */
	public short getOpcode(){
		return opcode;
	}
	
	
	/** Write the object to the stream as needed. Use 'write' methods of the ByteBuf. The byte count is automatically added. 
	 * @warning Do not modify reader or writer indexes.
	 * @param stream The byte stream on which to write the object.
	 * @param object The object to write.
	 * @param table The serializing table to write sub-objects to the stream. May be null.
	 */
	abstract protected void write(ByteBuf stream, Item object, SerializingTable table) throws RuntimeException;
	
	/**	Read the object from the stream. The buffer is in the same order as it was written. Use 'read' methods of the ByteBuf.
	 * @warning Do not modify reader or writer indexes.
	 * @param stream The byte stream on which to read the object.
	 * @param bytesToRead The number of bytes that were written for this object.
	 * @param table The serializing table to read sub-objects from the stream. May be null.
	 * @return The object that was read.
	 */
	abstract protected Item read(ByteBuf stream, int bytesToRead, SerializingTable table) throws RuntimeException;
	
	/**
	 * Used to get the Object type. For example, if this NetworkSerializer processes String objects, this MUST return String.class
	 * @return NetworkSerializerObject.class
	 */
	abstract protected Class<Item> getSerializableObjectType();
}
